#ifndef ZIL_IMAGE
#define ZIL_IMAGE

/* Generated with cbindgen:0.26.0 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>


typedef enum ZImageColorspace {
  /**
   * Unknown image colorspace
   */
  UnknownColorspace = 0,
  /**
   * Red, Green , Blue
   */
  RGB,
  /**
   * Red, Green, Blue, Alpha
   */
  RGBA,
  /**
   * YUV colorspace
   */
  YCbCr,
  /**
   * Grayscale colorspace
   */
  Luma,
  /**
   * Grayscale with alpha colorspace
   */
  LumaA,
  YCCK,
  /**
   * Cyan , Magenta, Yellow, Black
   */
  CMYK,
  /**
   * Blue, Green, Red
   */
  BGR,
  /**
   * Blue, Green, Red, Alpha
   */
  BGRA,
} ZImageColorspace;

/**
 * Image depth information
 *
 * This enum gives information about image depths
 *
 * The image depths also give you the information for
 * which we represent image pixels
 *
 * U8  -> 8 bit depth, image is represented as uint8_t (unsigned char)
 * U16 -> 16 bit depth, image is represented as uint16_t ( unsigned short)
 * F32  -> using float32, image is represented as float
 */
typedef enum ZImageDepth {
  /**
   * Image depth is unknown
   */
  UnknownDepth = 0,
  /**
   *8-bit images
   */
  U8 = 1,
  /**
   * 16 bit images
   */
  U16 = 2,
  /**
   * Float 32 images
   */
  F32 = 4,
} ZImageDepth;

/**
 * Various image formats that are supported by the library
 * in one way or another
 *
 * Some of them have partial support, i.e there is only a decoder bundled in
 * while others have full support
 */
typedef enum ZImageFormat {
  /**
   * Any unknown format
   */
  UnknownFormat = 0,
  /**
   * Joint Photographic Experts Group
   */
  JPEG,
  /**
   * Portable Network Graphics
   */
  PNG,
  /**
   * Portable Pixel Map image
   */
  PPM,
  /**
   * Photoshop PSD component
   */
  PSD,
  /**
   * Farbfeld format
   */
  Farbfeld,
  /**
   * Quite Okay Image
   */
  QOI,
  /**
   * JPEG XL, new format
   */
  JPEG_XL,
  /**
   * Radiance HDR decoder
   */
  HDR,
  /**
   * Windows Bitmap Files
   */
  BMP,
} ZImageFormat;

/**
 * Various representations of things that may go wrong
 */
typedef enum ZStatusType {
  /**
   * Everything is okay, operation succeeded
   */
  Ok = 0,
  /**
   * The buffer passed to a function wasn't enough to
   * store the results
   */
  NotEnoughSpaceInDest,
  /**
   * An error that doesn't fit into a specific genre
   */
  Generic,
  /**
   * An error originating from decoding
   */
  DecodeErrors,
  /**
   * An error originating from Input output errors
   */
  IoErrors,
  /**
   * Malloc failed
   */
  MallocFailed,
  /**
   * Status is null, indicates the passed status value is null
   * useful when we have been asked for status code but
   * passed a null status
   */
  NullStatus,
} ZStatusType;

/**
 * Represents a single image
 *
 * This is the main entry point for all images inside zune, most decoders will return this,
 * most image operations manipulate this and most encoders encode from this
 *
 * The representation of images is vector of frames each frame containing a plannar channel layout
 *
 */
typedef struct Image Image;

typedef struct Image ZImage;

/**
 * Image metadata details
 */
typedef struct ZImageMetadata {
  unsigned int width;
  unsigned int height;
  enum ZImageDepth depth;
  enum ZImageColorspace colorspace;
  enum ZImageFormat format;
} ZImageMetadata;

/**
 * A status indicator that tells you more about things that went wrong
 *
 *
 * To create an instance use `zil_status_new`
 *
 * To get an enum which contains more details about the execution use `zil_status_code`
 * and to get the message raised by an exception use `zil_status_message`
 *
 * For quickly checking if an operation succeeded, you can use `zil_status_ok` that
 * returns a boolean indicating whether something worked, true if operation succeeded, false otherwise
 *
 *
 */
typedef struct ZStatus {
  enum ZStatusType status;
} ZStatus;

/**
 *
 */
void __chkstk(void);

void _fltused(void);

void hell(ZImage *c);

/**
 * \brief  Decode image headers  of bytes already in memory
 *
 * This reads and returns common image metadata, like width, depth,colorspace
 * it does not attempt to return extra details of images such as exif
 *
 * \returns: A struct containing details and sets status to be successful In case of failure in decoding or status being null, returns a zeroed struct.
 *
 */
struct ZImageMetadata zil_decode_headers(const unsigned char *input,
                                         unsigned long input_size,
                                         struct ZStatus *status);

/**
 * Free a memory region that was allocated by zil_malloc or internally by the library
 *
 * E.g. free a pointer returned by `zil_imread`
 *
 * \param ptr: A pointer allocated by `zil_malloc`
 *
 */
void zil_free(void *ptr);

/**
 * \brief Guess the format of an image
 *
 * This function inspects the first few bytes of an image file
 * to determine the actual image codec the file is in
 *
 * If the format cannot be deduced or it's unknown returns `ZImageFormat::UnknownDepth`
 *
 * @param bytes: A memory address containing image data, must point to a valid memory address
 * @param size: Size of the bytes parameter, must not exceed `bytes` length
 *
 * @returns ZImageFormat the image format of the bytes, or ZImageFormat::UnknownDepth if the image is unknown
 *
 */
enum ZImageFormat zil_guess_format(const unsigned char *bytes,
                                   long size);

/**
 *\brief Decode an image already in memory
 *
 * This decodes an image loaded to memory, and returns a pointer to the first pixel
 *
 * The size of the array is strictly `image_width * image_height * image_depth * channels`
 *
 * @param input: Input array of image bytes
 * @param input_size: Input size for the image bytes
 * @param width: Image width, will be filled after decoding with the decoded image width, can be null
 * @param height: Image height, will be filled after decoding with the decoded image height, can be null
 * @param depth: Image depth, will be filled after decoding with the decoded image depth, can be null
 * @param channels: Number of channels, will be filled after decoding with the decoded image channels, can be null
 * @param status: Image status,used to inform the caller if operations were successful
 *
 */
const char *zil_imdecode(const unsigned char *input,
                         unsigned int input_size,
                         unsigned int *width,
                         unsigned int *height,
                         enum ZImageDepth *depth,
                         int *channels,
                         struct ZStatus *status);

/**
 * Decode from a byte array in memory and write pixels to `output`
 *
 * Pixels written are strictly `image_width * image_height * image_depth * channels`
 *
 * @param input: Input array of image bytes
 * @param input_size: Input size for the image bytes
 * @param output: Output array where to write decoded pixels
 * @param output_size: Size of `output`
 * @param width: Image width, will be filled after decoding with the decoded image width, can be null
 * @param height: Image height, will be filled after decoding with the decoded image height, can be null
 * @param depth: Image depth, will be filled after decoding with the decoded image depth, can be null
 * @param channels: Number of channels, will be filled after decoding with the decoded image channels, can be null
 * @param status: Image status,used to inform the caller if operations were successful
 *
 */
void zil_imdecode_into(const unsigned char *input,
                       unsigned int input_size,
                       unsigned char *output,
                       unsigned int output_size,
                       unsigned int *width,
                       unsigned int *height,
                       enum ZImageDepth *depth,
                       int *channels,
                       struct ZStatus *status);

/**
 *\brief Creates a new depth that can be passed to functions that require
 * depth
 *
 * \returns ImageDepth with a value of ImageDepth::Unknown
 */
enum ZImageDepth zil_imdepth_new(void);

/**
 * Read image contents of a file and return a pointer to the decoded bytes
 *
 *
 * The allocator used is `libc::malloc`
 *
 * @param file: The file to decode
 *
 * @param width: Image width, after successful decoding the value stored will be the image width,
 * can be null
 *
 * @param height: Image height, after successful decoding, the value stored will be the image height,can be null
 *
 * @param depth: Image depth, after successful decoding, the value stored will be the image depth,can be null
 *
 * @param channels: Number of channels in the image, after successful decoding, the value stored will be the
 * image channels, can be null
 *
 * @param status: Image decoding status, query this before inspecting contents of buf, CANNOT be null
 *
 * \returns A pointer to the first element of the image pixels, the length of this array is strictly
 * `width * height * channels * depth`
 *
 * In case the decoder cannot decode, returns `null` and the reason
 * why it can't be decoded is given in `status` parameter
 *
 */
const char *zil_imread(const char *file,
                       unsigned int *width,
                       unsigned int *height,
                       enum ZImageDepth *depth,
                       int *channels,
                       struct ZStatus *status);

/**
 *\brief Load an image from a file and return it's contents
 *
 * if `status` parameter  is null, returns early
 *
 *
 * @param file: File path, MUST be null terminated
 *
 * @param buf: Output buffer, contents of decoding will be written here
 *
 * @param buf_size: Buffer size, the size of output buffer
 *
 * @param width: Image width, after successful decoding the value stored will be the image width,
 * can be null
 *
 * @param height: Image height, after successful decoding, the value stored will be the image height,can be null
 *
 * @param depth: Image depth, after successful decoding, the value stored will be the image depth,can be null
 *
 * @param channels: Number of channels in the image, after successful decoding, the value stored will be the
 * image channels, can be null
 *
 * @param status: Image decoding status, query this before inspecting contents of buf, CANNOT be null
 */
void zil_imread_into(const char *file,
                     unsigned char *output,
                     unsigned int output_size,
                     unsigned int *width,
                     unsigned int *height,
                     enum ZImageDepth *depth,
                     int *channels,
                     struct ZStatus *status);

/**
 * Allocate a region of memory
 *
 * This uses libc's malloc hence on most platforms it should be the system allocator
 *
 * \param size: Memory size
 */
void *zil_malloc(size_t size);

/**
 * Read image headers from a file and return common information such as width, height depth and colorspace
 *
 * \param file: Null terminated
 */
struct ZImageMetadata zil_read_headers(const char *file,
                                       struct ZStatus *status);

/**
 * Return the status code contained in the ZImStatus
 *
 * \param status The status struct for which to extract a status from
 *
 * \returns ZStatusCode, an enum that indicates if everything is okay or something went wrong
 */
enum ZStatusType zil_status_code(const struct ZStatus *status);

/**
 * Returns a null terminated string that contains more details about
 * what went wrong
 *
 * \param status: The image status for which we are extracting the message from
 *
 * \returns: The message contained, if `status` is null, returns null
 */
const char *zil_status_message(const struct ZStatus *status);

/**
 * Create a new image status struct
 *
 * This can be passed around to functions that report progress via
 * status
 */
struct ZStatus zil_status_new(void);

/**
 * \brief Check if image operation succeeded
 *
 * @param status: Image status
 *
 * @returns true if everything is okay, if status is null or something went bad returns false
 */
bool zil_status_ok(const struct ZStatus *status);

#endif /* ZIL_IMAGE */
